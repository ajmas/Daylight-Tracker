/*
	A basic extension of the java.awt.Frame class
 */

package ajmas74.daylighttracker;
import java.awt.*;
import javax.swing.*;
import java.util.*;

public class DaylightTrackerFrame extends Frame
{
	JLabel basePanel = null;
	ImageIcon theImage = null;
	
	public DaylightTrackerFrame()
	{
		// This code is automatically generated by Visual Cafe when you add
		// components to the visual environment. It instantiates and initializes
		// the components. To modify the code, only use code syntax that matches
		// what Visual Cafe can generate, or Visual Cafe may be unable to back
		// parse your Java file into its visual environment.
		//{{INIT_CONTROLS
		setLayout(new BorderLayout() );
		setVisible(false);
		setSize(531,307);
		setTitle("Daylight Tracker");
		//}}

		//setResizable(false);

		theImage = new ImageIcon ( new String ("Earth 001.jpg") );
		if (theImage == null) System.out.println(" Hello ");
		
		basePanel = new JLabel(theImage);
		add(basePanel);

		setBounds( 100, 100, theImage.getIconWidth(), theImage.getIconHeight() );
		
		//{{INIT_MENUS
		//}}

		//{{REGISTER_LISTENERS
		SymWindow aSymWindow = new SymWindow();
		this.addWindowListener(aSymWindow);
		//}}
	}

	public DaylightTrackerFrame(String title)
	{
		this();
		setTitle(title);
	}
/*

	public void paint ( Graphics g ) {
		super.paint(g);
		int windowWidth = this.getSize().width;
		int windowHeight = this.getSize().height;
		g.drawLine ( windowWidth / 2, 0, windowWidth / 2, windowHeight );
		g.drawLine ( 0, windowHeight / 2, windowWidth, windowHeight / 2);
		
		//theImage.setIconWidth(windowWidth);
		//theImage.setIconHeight(windowHeight);
	//	if (firstdraw) {
			//g.setXORMode(new Color(255,255,255));
			if ( System.getProperty("java.version").equals("1.2") ) {
				System.out.println("A " + System.getProperty("java.version"));
				Graphics2D g2 = (Graphics2D) g;
				g2.setComposite(AlphaComposite.SrcOver);
				g2.setColor(Color.black);
				float alpha = 0.5f;
				AlphaComposite ac = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, alpha);
				g2.setComposite(ac);
				drawNight(g);
				ac = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1.0f);
				g2.setComposite(ac);				
			} else {
				drawNight(g);
			}
			g.setColor(new Color ( 255, 0, 0 ) );
			g.drawString(new String("Hello"), 5, 20 );
				
			
		//	firstdraw = false;
		//}
	}
*/	
	int ydots = 0;
	int xdots = 0;
	int onoon = -1;		      /* Previous pixel longitude of noon */
	int[] wtab = null;
	int[] wtab1 = null;
	long cctime = 0;   /* Time to display (real or simulated) */
	//long lctime = 0;   /* Last full calculation time */
	int wtabsize;		      /* Width table size */
	
	void drawNight ( Graphics g ) {
		int[] wtabs = null;
			
		Date theCurrentDate = new Date();
		
		
		System.out.println("theCurrentDate = " + theCurrentDate);
		System.out.println("theCurrentDate as GMT = " + theCurrentDate.toGMTString() );
		System.out.println("getTimezoneOffset() = " + theCurrentDate.getTimezoneOffset() );
		
		// Adjust the time to GMT time
		theCurrentDate.setMinutes( theCurrentDate.getMinutes() + theCurrentDate.getTimezoneOffset() );
		
		System.out.println("theCurrentDate = " + theCurrentDate);		
		
		//lctime = 0;
		onoon = -1;
		
		wtabsize = this.getSize().height;
		wtab = new int[wtabsize];
		wtab1 = new int[wtabsize];
		
		for ( int i = 0; i < wtabsize; i++) {
			wtab[i] = -1;
			wtab1[i] = -1;
		}
		
		xdots = this.getSize().width;
    	ydots = this.getSize().height;  	
	
		sunPos(calcJulianTime(theCurrentDate), false);
		System.out.println( " sunra = " + sunra +
		                    ", sundec = " + sundec +
		                    ", sunrv = " + sunrv +
		                    ", sunlong = " + sunlong ); 

		double gt = gmst(calcJulianTime(theCurrentDate));
		
		sunlong = fixangle(180.0 + (sunra - (gt * 15)));
    	int xl = (int)( sunlong * (xdots / 360.0) );
    
		wtab = projillum(wtab, xdots, ydots, sundec);
		
	//	for ( int i = 0; i < wtab.length; i++ ) {
	//		wtab[i] = xdots - wtab[i];
	//	}
		
		wtabs = wtab;
		wtab = wtab1;
		wtab1 = wtabs;
		
		movetermB( g, wtab1, xl, wtab, onoon, xdots, ydots);
		onoon = xl;
	}

	/*  calcJulianDate  --  Convert internal GMT date and time
	    to Julian day and fraction.  */
	long calcJulianDate ( Date theDate ) {

		int date = theDate.getDate();
		int year = theDate.getYear() + 1900;
		int month = theDate.getMonth() + 1;
		
		System.out.println("year = " + year);
		
		if (month > 2) {
			month = month - 3;
		} else {
			month = month + 9;
			year--;
		}

		int century = (int) (year / 100L);
		year -= 100 * century;

		return date + (century * 146097L) / 4 + (year * 1461L) / 4 +
		       (month * 153L + 2) / 5 + 1721119L;
	}

	double calcJulianTime ( Date theDate ) {
	    return ( calcJulianDate (theDate) - 0.5)
	            + (( (long) (theDate.getSeconds()) ) +
		        60L * (theDate.getMinutes() + 60L * theDate.getHours() ))
		        / 86400.0;
	}
	
	/* Degree -> Radian */
	double degreesToRadians ( double x ) {
		return ((x) * (Math.PI / 180.0));
	}
	
	/* Radian -> Degree*/
	double radiansToDegrees ( double x ) {
		return ((x) / (Math.PI / 180.0));
	}

	/*  KEPLER  --	Solve the equation of Kepler.  */

	double kepler(double m, double ecc)	{
	    double e;
	    double delta;
	    double EPSILON = 1E-6;

	    e = m = degreesToRadians (m);
	    do {
			delta = e - ecc * Math.sin(e) - m;
			e -= delta / (1 - ecc * Math.cos(e));
	    } while (Math.abs(delta) > EPSILON);
	    return e;
	}
	
	/* Fix angle */
	double fixangle( double a ) {
		return ((a) - 360.0 * (Math.floor((a) / 360.0)));
	}
	
	
	double sunra;
	double sundec;
	double sunrv;
	double sunlong;
	
	void sunPos(double jd, boolean apparent) {
		
	    double t; double t2; double t3; double l; 
	    double m; double e; double ea; double v;
	    double theta; double omega; double eps;

	    /* Time, in Julian centuries of 36525 ephemeris days,
	       measured from the epoch 1900 January 0.5 ET. */

	    t = (jd - 2415020.0) / 36525.0;
	    t2 = t * t;
	    t3 = t2 * t;

	    /* Geometric mean longitude of the Sun, referred to the
	       mean equinox of the date. */

	    l = fixangle(279.69668 + 36000.76892 * t + 0.0003025 * t2);

	    /* Sun's mean anomaly. */

	    m = fixangle(358.47583 + 35999.04975*t - 0.000150*t2 - 0.0000033*t3);

	    /* Eccentricity of the Earth's orbit. */

	    e = 0.01675104 - 0.0000418 * t - 0.000000126 * t2;

	    /* Eccentric anomaly. */

	    ea = kepler(m, e);

	    /* True anomaly */

	    v = fixangle(2 * radiansToDegrees(
	    	Math.atan(Math.sqrt((1 + e) / (1 - e))  * Math.tan(ea / 2))));

	    /* Sun's true longitude. */

	    theta = l + v - m;

	    /* Obliquity of the ecliptic. */

	    eps = 23.452294 - 0.0130125 * t - 0.00000164 * t2 + 0.000000503 * t3;

	    /* Corrections for Sun's apparent longitude, if desired. */

	    if (apparent) {
	       omega = fixangle(259.18 - 1934.142 * t);
	       theta = theta - 0.00569 - 0.00479 * Math.sin( degreesToRadians(omega));
	       eps += 0.00256 * Math.cos( degreesToRadians (omega));
	    }

	    /* Return Sun's longitude and radius vector */

	    sunlong = theta;
	    sunrv = (1.0000002 * (1 - e * e)) / (1 + e * Math.cos(degreesToRadians(v)));

	    /* Determine solar co-ordinates. */

	    sunra = fixangle( radiansToDegrees( 
	    		Math.atan2(Math.cos(degreesToRadians(eps)) * Math.sin(degreesToRadians(theta)),
	    		Math.cos(degreesToRadians(theta)))
	    	    ));
	    sundec = radiansToDegrees( Math.asin(
	    		Math.sin(degreesToRadians(eps)) * Math.sin(degreesToRadians(theta))
	    		));
	}
	
	/* Extract Sign */
	double sgn( double x) {
		return (((x) < 0) ? -1 : ((x) > 0 ? 1 : 0));
	}
	
	/*  GMST  --  Calculate Greenwich Mean Siderial Time for a given
	      instant expressed as a Julian date and fraction.	*/
	double gmst( double jd ) {
		
	    double t; double theta0;

	    /* Time, in Julian centuries of 36525 ephemeris days,
	       measured from the epoch 1900 January 0.5 ET. */

	    t = ((Math.floor(jd + 0.5) - 0.5) - 2415020.0) / 36525.0;

	    theta0 = 6.6460656 + 2400.051262 * t + 0.00002581 * t * t;

	    t = (jd + 0.5) - (Math.floor(jd + 0.5));

	    theta0 += (t * 24.0) * 1.002737908;

	    theta0 = (theta0 - 24.0 * (Math.floor(theta0 / 24.0)));

	    return theta0;
	}
	
	int TERMINC = 100;  /* Circle segments for terminator */
	
	/*  PROJILLUM  --  Project illuminated area on the map.  */
	int[] projillum( int[] lwtab, int xdots, int ydots, double dec)
	{
	    //int i;
	    boolean ftf = true;
	    int ilon;  int ilat;  int lilon = 0;  int lilat = 0;  int xt;
	    double m;  double x;  double y;  double z;  double th;
	    double lon;  double lat;  double s;  double c;

	    /* Clear unoccupied cells in width table */

	    for (int i = 0; i < ydots; i++) {
			lwtab[i] = -1;
	    }

	    /* Build transformation for declination */

	    s = Math.sin(-degreesToRadians(dec));
	    c = Math.cos(-degreesToRadians(dec));

	    /* Increment over a semicircle of illumination */

	    for (th = -(Math.PI / 2); th <= Math.PI / 2 + 0.001; th += Math.PI / TERMINC) {

			/* Transform the point through the declination rotation. */

			x = -s * Math.sin(th);
			y = Math.cos(th);
			z = c * Math.sin(th);

			/* Transform the resulting co-ordinate through the
			   map projection to obtain screen co-ordinates. */

			lon = (y == 0 && x == 0) ? 0.0 : radiansToDegrees ( Math.atan2(y, x));
			lat = radiansToDegrees (Math.asin(z));

			ilat = (int)( ydots - (lat + 90) * (ydots / 180.0) );
			ilon = (int)( lon * (xdots / 360.0) );

			if (ftf) {
			    /* First time.  Just save start co-ordinate. */
			    lilon = ilon;
			    lilat = ilat;
			    ftf = false;
			} else {

			    /* Trace out the line and set the width table. */

			    if (lilat == ilat) {
					lwtab[(ydots - 1) - ilat] = 2 * (ilon == 0 ? 1 : ilon);
			    } else {
					m = ((double) (ilon - lilon)) / (ilat - lilat);
					for (int i = lilat; i != ilat; i += sgn(ilat - lilat)) {
					    xt = (int)( lilon + Math.floor((m * (i - lilat)) + 0.5) );
					    lwtab[(ydots - 1) - i] = 2 * (xt == 0 ? 1 : xt);
					}
			    }
			    lilon = ilon;
			    lilat = ilat;
			}
	    }

	    /* Now tweak the widths to generate full illumination for
	       the correct pole. */

	    if (dec < 0.0) {
			ilat = ydots - 1;
			lilat = -1;
	    } else {
			ilat = 0;
			lilat = 1;
	    }

	    for (int i = ilat; i != ydots / 2; i += lilat) {
			if (lwtab[i] != -1) {
			    while (true) {
					lwtab[i] = xdots;
					if (i == ilat) {
					    break;
					}
					i -= lilat;
			    }
			    break;
			}
	    }
	    
	    return lwtab;
	}


	void assert( boolean assertion ) {
		if (!assertion) {
			System.out.println("assertion error");
		}
	}

	void assert( boolean assertion, String theTest) {
		if (!assertion) {
			System.out.println("assertion error : " + theTest + " resulted false");
		}
	}
	
/*  XSPAN  --  Complement a span of pixels.  Called with line in which
	       pixels are contained, leftmost pixel in the  line,  and
	       the   number   of   pixels   to	 complement.   Handles
	       wrap-around at the right edge of the screen.  */

	void xspan( Graphics g, int pline, int leftp, int npix)
	{
	    assert(npix <= xdots, "npix <= xdots");
	    assert(pline >= 0 && pline < ydots, "pline >= 0 && pline < ydots");
	    leftp = leftp % xdots;

		if ( g == null ) {
			System.out.println("Graphics is null");
			return;
		}
	
	    if ((leftp + npix) > xdots) {
			g.drawLine( leftp, pline, (xdots - 1), pline);
			g.drawLine( 0, pline, ((leftp + npix) - (xdots + 1)), pline);
	    } else {
			g.drawLine( leftp, pline, leftp + (npix - 1), pline);
	    }

	}

	/*  MOVETERM  --  Update illuminated portion of the globe.  */

	void moveterm(Graphics g, int[] wtab, int noon, int[] otab,
	              int onoon, int xdots, int ydots)
	{
		
	    int ol, oh, nl, nh;
/*
		int[] wtabxx = wtab;
		wtab = new int[wtabxx.length];
		for (int i = 0; i < wtabxx.length; i++ ) {
			wtab[i] =  wtabxx[(wtabxx.length-1) - i];
		}
		
		int[] otabxx = otab;
		otab = new int[otabxx.length];
		for (int i = 0; i < otabxx.length; i++ ) {
			otab[i] =  otabxx[(otabxx.length-1) - i];
		}
*/		
	    for (int i = 0; i < ydots; i++) {
		
		//System.out.println(" wtab[i] = " + wtab[i] );
		/* If line is off in new width table but is set in
		   the old table, clear it. */

		if (wtab[i] < 0) {
		    if (otab[i] >= 0) {
			xspan(g, i, ((onoon - (otab[i] / 2)) + xdots) % xdots,
			   otab[i]);
		    }
		} else {

		    /* Line is on in new width table.  If it was off in
		       the old width table, just draw it. */

		    if (otab[i] < 0) {
		       xspan(g, i, ((noon - (wtab[i] / 2)) + xdots) % xdots,
			  wtab[i]);
		    } else {

			/* If both the old and new spans were the entire
	                   screen, they're equivalent. */

			if ((otab[i] == wtab[i]) && (wtab[i] == xdots)) {
			    continue;
			}

			/* The line was on in both the old and new width
			   tables.  We must adjust the difference in the
			   span.  */

			ol =  ((onoon - (otab[i] / 2)) + xdots) % xdots;
			oh = (ol + otab[i]) - 1;
			nl =  ((noon - (wtab[i] / 2)) + xdots) % xdots;
			nh = (nl + wtab[i]) - 1;

			/* If spans are disjoint, erase old span and set
			   new span. */

			if (oh < nl || nh < ol) {
			    xspan(g, i, ol, (oh - ol) + 1);
			    xspan(g, i, nl, (nh - nl) + 1);
			} else {
			    /* Clear portion(s) of old span that extend
			       beyond end of new span. */
			    if (ol < nl) {
				xspan(g, i, ol, nl - ol);
				ol = nl;
			    }
			    if (oh > nh) {
				xspan(g, i, nh + 1, oh - nh);
				oh = nh;
			    }
			    /* Extend existing (possibly trimmed) span to
			       correct new length. */
			    if (nl < ol) {
					xspan(g, i, nl, ol - nl);
			    }
			    if (nh > oh) {
				xspan(g, i, oh + 1, nh - oh);
			    }
			}
		    }
		}
		otab[i] = wtab[i];
	    }
	}


	/*  MOVETERM  --  Update illuminated portion of the globe.  */

	void movetermB (Graphics g, int[] wtab, int noon, int[] otab,
	                int onoon, int xdots, int ydots) {
		
	    int ol, oh, nl, nh;

	/* This is for handling the fact that we want to draw night
	   and not day. */
		for ( int i = 0; i < ydots; i++ ) {
			wtab[i] = xdots - wtab[i];
			if (wtab[i] == 0)
				wtab[i] = -1;
			else if (wtab[i] > xdots)
				wtab[i] = xdots;
		}
		
		noon = (xdots / 2) + noon;
		if ( noon > xdots ) {
			noon = noon - xdots;
		}
	/* end midnight and night adjustments */
		
	    for (int i = 0; i < ydots; i++) {
		
		if (wtab[i] < 0) {
		    if (otab[i] >= 0) {
			xspan(g, i, ((onoon - (otab[i] / 2)) + xdots) % xdots,
			   otab[i]);
		    }
		} else {

		    /* Line is on in new width table.  If it was off in
		       the old width table, just draw it. */

		    if (otab[i] < 0) {
		       xspan(g, i, ((noon - (wtab[i] / 2)) + xdots) % xdots,
			  wtab[i]);
		    } else {

			/* If both the old and new spans were the entire
	                   screen, they're equivalent. */

			if ((otab[i] == wtab[i]) && (wtab[i] == xdots)) {
			    continue;
			}

			/* The line was on in both the old and new width
			   tables.  We must adjust the difference in the
			   span.  */

			ol =  ((onoon - (otab[i] / 2)) + xdots) % xdots;
			oh = (ol + otab[i]) - 1;
			nl =  ((noon - (wtab[i] / 2)) + xdots) % xdots;
			nh = (nl + wtab[i]) - 1;

			/* If spans are disjoint, erase old span and set
			   new span. */

			if (oh < nl || nh < ol) {
			    xspan(g, i, ol, (oh - ol) + 1);
			    xspan(g, i, nl, (nh - nl) + 1);
			} else {
			    /* Clear portion(s) of old span that extend
			       beyond end of new span. */
			    if (ol < nl) {
				xspan(g, i, ol, nl - ol);
				ol = nl;
			    }
			    if (oh > nh) {
				xspan(g, i, nh + 1, oh - nh);
				oh = nh;
			    }
			    /* Extend existing (possibly trimmed) span to
			       correct new length. */
			    if (nl < ol) {
					xspan(g, i, nl, ol - nl);
			    }
			    if (nh > oh) {
				xspan(g, i, oh + 1, nh - oh);
			    }
			}
		    }
		}
		otab[i] = wtab[i];
	    }
	}


	void drawLongitudes ( Graphics g) {		
	}
	
	
    /**
     * Shows or hides the component depending on the boolean flag b.
     * @param b  if true, show the component; otherwise, hide the component.
     * @see java.awt.Component#isVisible
     */
    public void setVisible(boolean b)
	{
		if(b)
		{
			setLocation(50, 50);
		}
		super.setVisible(b);
	}

	static public void main(String args[])
	{
		(new DaylightTrackerFrame()).setVisible(true);
	}
	
	public void addNotify()
	{
	    // Record the size of the window prior to calling parents addNotify.
	    Dimension d = getSize();
	    
		super.addNotify();

		if (fComponentsAdjusted)
			return;

		// Adjust components according to the insets
		setSize(getInsets().left + getInsets().right + d.width, getInsets().top + getInsets().bottom + d.height);
		Component components[] = getComponents();
		for (int i = 0; i < components.length; i++)
		{
			Point p = components[i].getLocation();
			p.translate(getInsets().left, getInsets().top);
			components[i].setLocation(p);
		}
		fComponentsAdjusted = true;
	}

    // Used for addNotify check.
	boolean fComponentsAdjusted = false;

	//{{DECLARE_CONTROLS
	//}}

	//{{DECLARE_MENUS
	//}}

	class SymWindow extends java.awt.event.WindowAdapter
	{
		public void windowClosing(java.awt.event.WindowEvent event)
		{
			Object object = event.getSource();
			if (object == DaylightTrackerFrame.this)
				Frame1_WindowClosing(event);
		}
	}
	
	void Frame1_WindowClosing(java.awt.event.WindowEvent event)
	{
		setVisible(false);		 // hide the Frame
	}
	
	
	class GMTdate extends Date {
		GMTdate () {
			super(System.currentTimeMillis());
		}
	}
	
}
